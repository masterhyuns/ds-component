import { Meta } from '@storybook/blocks';

<Meta title="Headless/SearchProvider/Docs" />

# SearchProvider 문서

## 개요

SearchProvider는 react-hook-form을 완전히 캡슐화한 헤드리스 검색 폼 관리 시스템입니다.

## 핵심 특징

- **완전한 추상화**: react-hook-form의 복잡성을 숨기고 간단한 API 제공
- **헤드리스 구조**: UI와 로직의 완전한 분리로 자유로운 스타일링 가능
- **유연한 렌더링**: 메타 기반 자동 렌더링부터 완전 커스텀까지 지원
- **실시간 유효성 검사**: onChange 모드로 즉각적인 피드백 제공
- **자동 상태 관리**: 폼 상태(dirty, touched, valid 등) 자동 추적

## SearchConfig 옵션

### 필수 속성

**id** (string)
- 폼의 고유 식별자

**fields** (FieldMeta[])
- 필드 메타 정의 배열

### 선택 속성

**name** (string)
- 폼의 이름

**onSubmit** (Function)
- 폼 제출 핸들러

**onReset** (Function)
- 폼 리셋 핸들러

**onChange** (Function)
- 값 변경 시 호출되는 핸들러
- 시그니처: `(name: string, value: any, values: FieldValues) => void`

**onDepends** (Record<string, FieldDependencyHandler>)
- 필드 간 의존성 규칙 정의
- 필드 값 변경 시 다른 필드의 상태를 동적으로 제어

**initialValues** (FieldValues)
- 폼 초기값

**autoSubmit** (boolean)
- 자동 제출 활성화 (기본값: false)

**autoSubmitDelay** (number)
- 자동 제출 지연 시간 (기본값: 500ms)

**defaultValues** (FieldValues)
- 폼 기본값 (기본값: {})

**layout** (object)
- 레이아웃 설정

## FieldMeta 구조

### 기본 속성

**id** (string) - 필수
- 필드 고유 ID

**name** (string) - 필수
- 필드 이름 (폼 데이터의 키)

**type** (SearchFieldType) - 필수
- 필드 타입 (text, select, number, date 등)

**label** (string)
- 라벨 텍스트

**placeholder** (string)
- 플레이스홀더

**defaultValue** (any)
- 기본값

**disabled** (boolean)
- 비활성화 여부

### 유효성 검사

**validation** (object)
- required: boolean 또는 string
- minLength: number 또는 object
- maxLength: number 또는 object
- pattern: RegExp 또는 object
- validate: Function

### 조건부 렌더링

**showWhen** (Function)
- 다른 필드 값에 따라 표시/숨김 제어

### 선택 필드용

**options** (Option[])
- select, radio 등에서 사용하는 옵션 목록

## 제공되는 Hooks

### useField(name)

개별 필드를 제어하는 훅

반환값:
- value: 현재 값
- setValue: 값 설정 함수
- onChange: onChange 핸들러
- onBlur: onBlur 핸들러
- error: 에러 메시지
- isDirty: 수정 여부
- isTouched: 터치 여부
- reset: 필드 리셋
- validate: 수동 유효성 검사

### useSearchForm()

전체 폼을 관리하는 훅

반환값:
- submit: 폼 제출
- reset: 폼 리셋
- getValues: 전체 값 가져오기
- getValue: 특정 필드 값
- setValues: 여러 값 설정
- setValue: 단일 값 설정
- validate: 전체 유효성 검사
- isSubmitting: 제출 중
- isDirty: 수정됨
- isValid: 유효함
- errors: 에러 목록

### useFieldValue(name)

특정 필드 값만 구독

### useArrayField(name)

동적 배열 필드 관리

반환값:
- items: 배열 아이템들
- add: 항목 추가
- remove: 항목 제거
- move: 순서 변경
- insert: 특정 위치 삽입
- clear: 전체 제거

## 렌더링 방식

### 1. 메타 기반 자동 렌더링

```jsx
<Field name="keyword" />
```

### 2. Render Prop 패턴

```jsx
<Field name="keyword" render=&#123;(field) => (
  <CustomInput &#123;...field&#125; />
)&#125; />
```

### 3. Children 함수 패턴

```jsx
<Field name="keyword">
  &#123;(field) => <CustomInput &#123;...field&#125; />&#125;
</Field>
```

### 4. 커스텀 컴포넌트

```jsx
<Field name="keyword" component={MyInput} />
```

## 사용 예제

### 기본 사용법

```jsx
const config = {
  id: 'search-form',
  fields: [
    {
      id: 'keyword',
      name: 'keyword',
      type: 'text',
      label: '검색어',
      validation: {
        required: '검색어는 필수입니다'
      }
    }
  ],
  onSubmit: async (data) => {
    console.log(data);
  }
};

function App() {
  return (
    <SearchProvider config={config}>
      <Field name="keyword" />
      <SearchButtons />
    </SearchProvider>
  );
}
```

### 조건부 필드

```jsx
{
  id: 'advanced',
  name: 'advanced',
  type: 'text',
  showWhen: (values) => values.mode === 'advanced'
}
```

### 커스텀 유효성 검사

```jsx
validation: {
  validate: (value) => {
    if (!value.includes('@')) {
      return '이메일 형식이 아닙니다';
    }
    return true;
  }
}
```

### 자동 제출

```jsx
const config = {
  autoSubmit: true,
  autoSubmitDelay: 1000,
  // ...
};
```

### 필드 간 의존성 관리 (onDepends) ✨

필드 간 의존성을 선언적으로 관리하여 비즈니스 로직을 config와 분리할 수 있습니다.

#### 기본 구조

```typescript
interface FieldDependencyHandler {
  dependencies: string[];                     // 의존하는 필드 이름 배열
  handler: (values, controller) => void;      // 의존성 변경 시 실행되는 함수
}
```

#### FieldController API

handler 함수에서 사용할 수 있는 필드 제어 API:

```typescript
controller.setValue(fieldName, value)              // 필드 값 설정
controller.setFieldDisabled(fieldName, disabled)   // 비활성화 상태
controller.setFieldReadonly(fieldName, readonly)   // 읽기 전용
controller.setFieldOptions(fieldName, options)     // 옵션 목록 (select 등)
controller.setFieldPlaceholder(fieldName, text)    // placeholder
controller.setFieldLabel(fieldName, text)          // label
controller.updateFieldMeta(fieldName, meta)        // 메타 정보 일괄 업데이트
controller.getValue(fieldName)                     // 필드 값 가져오기
controller.getValues()                             // 전체 값 가져오기
```

#### 예제 1: 국가/도시 선택

```jsx
import type &#123; FieldDependencyHandler, FieldValues, FieldController &#125; from 'sd-search-box';

// Config는 순수하게 유지
const config = {
  id: 'location',
  fields: [
    {
      name: 'country',
      type: 'select',
      options: [
        { label: '한국', value: 'korea' },
        { label: '미국', value: 'usa' },
      ]
    },
    {
      name: 'city',
      type: 'select',
      disabled: true,
      options: []
    }
  ]
};

// 비즈니스 로직은 onDepends로 분리
const dependencies: Record<string, FieldDependencyHandler> = {
  city: {
    dependencies: ['country'],
    handler: (values: FieldValues, controller: FieldController) => {
      if (!values.country) {
        controller.setFieldDisabled('city', true);
        controller.setFieldOptions('city', []);
      } else {
        controller.setFieldDisabled('city', false);
        controller.setFieldOptions('city', getCitiesByCountry(values.country));
      }
    }
  }
};

function SearchForm() {
  return (
    <SearchProvider config={config} onDepends={dependencies}>
      <Field name="country" />
      <Field name="city" />
    </SearchProvider>
  );
}
```

#### 예제 2: 복합 의존성

여러 필드에 의존하는 경우:

```jsx
const dependencies = {
  discount: {
    dependencies: ['customerGrade', 'totalAmount'],
    handler: (values: FieldValues, controller: FieldController) => {
      const { customerGrade, totalAmount } = values;

      if (customerGrade === 'vip' && totalAmount >= 100000) {
        controller.setFieldDisabled('discount', false);
        controller.setFieldPlaceholder('discount', '최대 30% 할인');
        controller.updateFieldMeta('discount', {
          validation: {
            max: { value: 30, message: '30% 초과 불가' }
          }
        });
      } else {
        controller.setFieldDisabled('discount', true);
        controller.setValue('discount', 0);
      }
    }
  }
};
```

#### 규칙 분리 패턴 (권장)

복잡한 프로젝트에서는 의존성 규칙을 별도 파일로 관리:

```jsx
// utils/searchDependencies.ts
export const productSearchDependencies: Record<string, FieldDependencyHandler> = &#123;
  city: &#123; /* ... */ &#125;,
  discount: &#123; /* ... */ &#125;,
&#125;;

// components/ProductSearch.tsx
import &#123; productSearchDependencies &#125; from '@/utils/searchDependencies';

<SearchProvider config={config} onDepends={productSearchDependencies}>
  {/* ... */}
</SearchProvider>
```

#### 동작 방식

1. 의존성 필드 (dependencies)의 값이 변경되면 자동으로 handler 실행
2. handler에서 FieldController API를 사용하여 대상 필드 제어
3. 초기 렌더링 시에도 모든 handler가 한 번 실행되어 초기 상태 설정
4. Config는 순수하게 유지되어 JSON 직렬화 가능

#### 장점

- ✅ Config와 비즈니스 로직 분리
- ✅ 재사용 가능한 의존성 규칙
- ✅ 타입 안전성 보장
- ✅ 테스트 용이성
- ✅ 선언적이고 읽기 쉬운 코드

### 외부에서 폼 제어하기 (formRef) ✨

`formRef`를 사용하면 SearchProvider **외부**에서 폼 API에 접근할 수 있습니다.

#### 기본 사용법

```jsx
import &#123; useRef &#125; from 'react';
import type &#123; SearchFormAPI &#125; from 'sd-search-box';

function MyPage() {
  // 1. ref 생성
  const searchFormRef = useRef<SearchFormAPI>(null);

  // 2. 외부에서 폼 제어
  const handleExternalAction = () => {
    // 현재 폼 값 가져오기
    const values = searchFormRef.current?.getValues();
    console.log('현재 검색 조건:', values);

    // 특정 필드 값 설정
    searchFormRef.current?.setValue('keyword', '새 검색어');

    // 폼 제출
    searchFormRef.current?.submit();

    // 폼 초기화
    searchFormRef.current?.reset();
  };

  return (
    <div>
      {/* 3. formRef prop 전달 */}
      <SearchProvider config={config} formRef={searchFormRef}>
        <Field name="keyword" />
      </SearchProvider>

      {/* 외부 컴포넌트에서 폼 제어 */}
      <button onClick={handleExternalAction}>
        외부에서 폼 조작
      </button>
    </div>
  );
}
```

#### 실시간 폼 값 표시

```jsx
function MyPage() {
  const searchFormRef = useRef<SearchFormAPI>(null);
  const [displayValues, setDisplayValues] = useState(&#123;&#125;);

  return (
    <div>
      <SearchProvider
        config={config}
        formRef={searchFormRef}
        onChange={(name, value, allValues) => {
          // 폼 값이 변경될 때마다 외부 state 업데이트
          setDisplayValues(allValues);
        }}
      >
        <Field name="keyword" />
      </SearchProvider>

      {/* 외부에서 실시간 폼 값 표시 */}
      <div className="search-summary">
        <h3>현재 검색 조건</h3>
        <p>키워드: {displayValues.keyword}</p>
        <button onClick={() => {
          searchFormRef.current?.setValue('keyword', 'RESET');
        }}>
          키워드 초기화
        </button>
      </div>
    </div>
  );
}
```

#### formRef API

`formRef.current`로 접근 가능한 모든 메서드:

```typescript
// 값 조회
formRef.current?.getValues()        // 전체 값
formRef.current?.getValue('name')   // 특정 필드 값

// 값 설정
formRef.current?.setValue('name', value)  // 특정 필드
formRef.current?.setValues({ ... })       // 전체 값

// 폼 제어
formRef.current?.submit()     // 폼 제출
formRef.current?.reset()      // 폼 초기화
formRef.current?.validate()   // 유효성 검사

// 폼 상태
formRef.current?.isSubmitting // 제출 중
formRef.current?.isDirty      // 수정 여부
formRef.current?.isValid      // 유효성
formRef.current?.errors       // 에러 목록
```

#### 언제 사용하나요?

**사용하는 경우:**
- SearchProvider 외부에서 폼 값에 접근해야 할 때
- 외부 버튼이나 이벤트로 폼을 제어해야 할 때
- 다른 컴포넌트에서 폼 상태를 참조해야 할 때

**사용하지 않는 경우:**
- SearchProvider 내부에서만 사용한다면 `useSearchForm()` 훅 사용
- 단순히 onChange로 값을 받고 싶다면 `onChange` prop 사용

## 성능 최적화

### 메모이제이션
- SearchProvider는 내부적으로 useMemo와 useCallback을 사용하여 불필요한 리렌더링 방지

### 구독 기반 업데이트
- useFieldValue 훅으로 특정 필드만 구독하여 성능 최적화

### 지연 검증
- mode: 'onChange'로 실시간 검증 제공 (필요시 onBlur나 onSubmit으로 변경 가능)

## 마이그레이션 가이드

### react-hook-form에서 마이그레이션

Before:
```jsx
const &#123; register, handleSubmit, formState: &#123; errors &#125; &#125; = useForm();
<input &#123;...register('keyword', &#123; required: true &#125;)&#125; />
```

After:
```jsx
const field = useField('keyword');
<input &#123;...field&#125; />
```

## 문제 해결

### 필드가 렌더링되지 않음
1. config.fields에 필드 메타가 정의되어 있는지 확인
2. Field 컴포넌트의 name prop이 정확한지 확인
3. showWhen 조건이 true를 반환하는지 확인

### 유효성 검사가 작동하지 않음
1. validation 규칙이 올바르게 정의되어 있는지 확인
2. mode: 'onChange'가 설정되어 있는지 확인
3. 커스텀 validate 함수가 boolean 또는 string을 반환하는지 확인

### 값이 업데이트되지 않음
1. onChange 핸들러가 올바르게 연결되어 있는지 확인
2. 커스텀 컴포넌트에서 onChange prop을 호출하는지 확인
3. controlled/uncontrolled 컴포넌트 충돌이 없는지 확인